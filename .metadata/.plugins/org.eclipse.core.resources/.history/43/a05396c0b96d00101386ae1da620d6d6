#include "device_config.h"
#include "Flash.h"
#include <string.h>
#include <stdbool.h>

// Define the address where configuration will be stored (the last page)
// Using FLASH_LAST_PAGE from flash.h makes this more consistent
#define CONFIG_FLASH_ADDRESS FLASH_LAST_PAGE

// --- Internal Helper Function Prototypes ---
static void Config_SetDefaults(DeviceConfiguration_t* config);
static uint32_t CalculateCRC32(const uint8_t* data, size_t length);

// Default settings function (remains the same)
static void Config_SetDefaults(DeviceConfiguration_t* config)
{
    // 1. Initialize all fields to 0 first (good practice to ensure no garbage values)
    memset(config, 0, sizeof(DeviceConfiguration_t));

    // 2. Set the header for integrity and versioning (CRITICAL!)
    config->magic_number = CONFIG_MAGIC_NUMBER;
    config->config_version = CONFIG_VERSION;
    // _header_padding is implicitly zeroed by memset

    // 3. Set System-wide Pump Physical Configuration defaults
    for (int i = 0; i < 8; i++) {
        config->PumpEnable[i] = 1;      // Default: All 8 physical pumps are enabled
        config->PumpDensity[i] = 1.0f;  // Default density (e.g., for water, or a generic liquid)
    }

    // 4. Set Chemical Recipe Definitions defaults (for 8 definable chemicals)
    // You can customize these default names
    char default_chem_names[8][20] = {
        "Chemical_01", "Chemical_02", "Chemical_03", "Chemical_04",
        "Chemical_05", "Chemical_06", "Chemical_07", "Chemical_08"
    };

    for (int i = 0; i < 8; i++) {
        // Set default name for each chemical
        strncpy(config->ChemicalName[i], default_chem_names[i], sizeof(config->ChemicalName[i]) - 1);
        config->ChemicalName[i][sizeof(config->ChemicalName[i]) - 1] = '\0'; // Ensure null-termination

        // Default: Each chemical recipe initially uses 1 pump
        config->PumpAmountPerChemical[i] = 1;

        // Initialize dispense instructions for each chemical recipe
        for (int j = 0; j < MAX_DISPENSE_OPTIONS_PER_CHEMICAL; j++) {
            // Use -1 or another clearly invalid value to signify an unused pump option
            config->ChemicalDispenseInstructions[i][j].pump_index = 0;
            config->ChemicalDispenseInstructions[i][j].amount = 0.0f; // Default amount is zero
        }
    }

    // _padding_for_flash_alignment is implicitly zeroed by memset

    // 5. CRC will be calculated and set during the Config_Save operation, so leave it 0 here.
    config->crc32_checksum = 0;
}
// CRC calculation function (remains the same)
static uint32_t CalculateCRC32(const uint8_t* data, size_t length)
{
    // IMPORTANT: For production, enable and use the STM32's hardware CRC peripheral!
    // It's much faster and more reliable.
    // Example using HAL CRC:
    // HAL_CRC_Accumulate(&hcrc, (uint32_t*)data, length / 4); // For word-aligned data
    // Or simpler: __HAL_RCC_CRC_CLK_ENABLE(); then use HAL_CRC_Calculate.

    // --- Placeholder Software CRC32 (NOT RECOMMENDED for production) ---
    uint32_t crc = 0xFFFFFFFFUL; // Initial value for CRC-32 (IEEE 802.3)
    for (size_t i = 0; i < length; i++) {
        crc ^= data[i];
        for (int j = 0; j < 8; j++) {
            if (crc & 0x00000001UL) {
                crc = (crc >> 1) ^ 0xEDB88320UL;
            } else {
                crc >>= 1;
            }
        }
    }
    return crc ^ 0xFFFFFFFFUL; // Final XOR
    // --- End Placeholder CRC32 ---
}

/**
 * @brief Saves the provided configuration struct from RAM to Flash.
 * This version correctly calculates the CRC and writes the struct in 8-byte chunks.
 * @param config A pointer to the DeviceConfiguration_t struct in RAM to save.
 * @return HAL_StatusTypeDef HAL_OK if successful, error otherwise.
 */
HAL_StatusTypeDef Config_Save(const DeviceConfiguration_t* config)
{
    if (config == NULL) {
        return HAL_ERROR;
    }

    HAL_StatusTypeDef status;
    DeviceConfiguration_t temp_config;

    // 1. Copy the source config to a temporary modifiable struct
    memcpy(&temp_config, config, sizeof(DeviceConfiguration_t));

    // 2. Calculate CRC on all data *before* the checksum field itself
    // The size for CRC calculation is the total struct size minus the size of the CRC field.
    size_t crc_data_size = sizeof(DeviceConfiguration_t) - sizeof(temp_config.crc32_checksum);
    temp_config.crc32_checksum = CalculateCRC32((const uint8_t*)&temp_config, crc_data_size);

    // 3. Erase the target flash page
    status = FlashErase(CONFIG_FLASH_ADDRESS);
    if (status != HAL_OK) {
        return status; // Return on erase failure
    }

    // 4. Write the entire struct to flash in 64-bit (8-byte) chunks
    uint64_t* data_ptr = (uint64_t*)&temp_config;
    uint32_t write_address = CONFIG_FLASH_ADDRESS;
    // Calculate how many 8-byte chunks to write.
    // Use ceiling division in case the struct size is not a perfect multiple of 8.
    int chunks = (sizeof(DeviceConfiguration_t) + 7) / 8;

    for (int i = 0; i < chunks; i++) {
        status = FlashWrite(write_address, data_ptr[i]);
        if (status != HAL_OK) {
            // If any write fails, the data is corrupt. It's best to return an error.
            // The page is already erased, so it will contain default 0xFF values.
            return status;
        }
        write_address += 8; // Move to the next 8-byte boundary
    }

    return HAL_OK;
}

/**
 * @brief Loads the configuration struct from Flash into RAM.
 * This version reads the data and performs full integrity checks.
 * @param config A pointer to the DeviceConfiguration_t struct in RAM to load into.
 * @return HAL_StatusTypeDef HAL_OK if load was successful and data is valid.
 *         HAL_ERROR if data is invalid/corrupt (in which case, defaults are loaded).
 */
HAL_StatusTypeDef Config_Load(DeviceConfiguration_t* config)
{
    if (config == NULL) {
        return HAL_ERROR;
    }

    // 1. Read the entire struct's worth of data from Flash into the provided RAM struct.
    uint64_t* dest_ptr = (uint64_t*)config;
    uint32_t read_address = CONFIG_FLASH_ADDRESS;
    int chunks = (sizeof(DeviceConfiguration_t) + 7) / 8;

    for (int i = 0; i < chunks; i++) {
        dest_ptr[i] = FlashRead(read_address);
        read_address += 8;
    }

    // --- 2. Perform Integrity and Validity Checks ---

    // Check 1: Is the magic number correct?
    // This is the first and most basic check to see if the data looks like our config.
    if (config->magic_number != CONFIG_MAGIC_NUMBER) {
        Config_SetDefaults(config);
        return HAL_ERROR;
    }

    // Check 2: Is the configuration version what we expect?
    // For now, we only support one version.
    if (config->config_version != CONFIG_VERSION) {
        Config_SetDefaults(config);
        return HAL_ERROR;
    }

    // Check 3: Is the CRC checksum valid?
    uint32_t stored_crc = config->crc32_checksum;
    size_t crc_data_size = sizeof(DeviceConfiguration_t) - sizeof(config->crc32_checksum);
    uint32_t calculated_crc = CalculateCRC32((const uint8_t*)config, crc_data_size);

    if (stored_crc != calculated_crc) {
        // CRC mismatch means data corruption. Load defaults for safety.
        Config_SetDefaults(config);
        return HAL_ERROR;
    }

    // If all checks pass, the data is valid.
    return HAL_OK;
}
